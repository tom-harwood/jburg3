delimiters "%","%"

// ** Start State **
start(table, uniqueStates) ::= <<
%classDef(table, uniqueStates)%
>>

// ** Property Access **
className() ::= <<%"";format="class.name"%>>

grammar() ::= <<%"";format="grammar.name"%>>

nodeClass() ::= <<%"";format="node.class"%>>

nodeTypeClass() ::= <<%"";format="nodeType.class"%>>

nonterminalClass() ::= <<%"";format="nonterminal.class"%>>

timestamp() ::=<<%"";format="timestamp"%>>

version() ::= <<%"";format="version"%>>

visitorClass() ::= <<%"";format="visitor.class"%>>

// ** Table Translation, mostly alphabetical **
assignState(methods) ::= <<
%if(methods.empty)%
node.setStateNumber(%s.statesByMethod.(methods).stateNumber%);
node.setTransitionTableLeaf(this);
%else%
%methods: { m | boolean b%m.name% = visitor.%m.name%(node); };separator="\n"%
%s.statesByMethod:predicatedState()%
%endif%
>>

classDef(table, uniqueStates) ::= <<
/* GENERATED CODE - Edits will be lost
 * Generated by JBurg3 %version()% %timestamp()% %grammar()%
 */

public class %className()%
{
    private final static int ERROR_STATE_NUM = 0;
    private final static int NULL_STATE_NUM = 1;

    private static int getStateNumber(%nodeClass()% node)
    {
        return node != null? node.getStateNumber(): NULL_STATE_NUM;
    }

    public void label(%visitorClass()% visitor, %nodeClass()% node)
    {
        if (node != null) {

            for (int i = 0; i < node.getSubtreeCount(); i++) {
                label(visitor, node.getSubtree(i));
            }

            switch(node.getNodeType()) {
                %productionTable(table)%
                default:
                    node.setStateNumber(ERROR_STATE_NUM);
                    break;
            }
        }
    }

    @SuppressWarnings("unchecked")
    public Object reduce(%visitorClass()% visitor, %nodeClass()% node, %nonterminalClass()% goalState)
    {
        if (node == null) {
            return nullHandler.reduce(visitor, node, goalState);
        } else if (node.getTransitionTableLeaf() != null) {
            TransitionEntry ti = (TransitionEntry)(node.getTransitionTableLeaf());
            return ti.reduce(this, visitor, node, goalState);
        } else {
            return errorHandler.reduce(visitor, node, goalState);
        }
    }

    public boolean canProduce(%nodeClass()% node,  %nonterminalClass()% goalState)
    {
        if (node != null && node.getTransitionTableLeaf() != null) {
            TransitionEntry ti = (TransitionEntry)(node.getTransitionTableLeaf());
            return ti.canProduce(node, goalState);
        } else {
            return false;
        }
    }

    %labelRoutines(table)%

    static abstract class TransitionEntry
    {
        abstract void assignState(%visitorClass()% visitor, %nodeClass()% node);
        abstract Object reduce(%className()% reducer, %visitorClass()% visitor, %nodeClass()% node, %nonterminalClass()% goalState);
        abstract boolean canProduce(%nodeClass()% node, %nonterminalClass()% goalState);
    }

    %uniqueStates:leafDefinition();separator="\n"%

    %errorState(table.errorState)%
    %nullState(table.nullPointerState)%
}
>>

errorClosure(c) ::= <<
case %c.nonterminal%: {
        Object result = reduce(visitor, node, %nonterminalClass()%.%c.source%);
        %if(c.postCallback)%
        result = visitor.%c.postCallback;format="closurePostCallback"%;
        %endif%
        return result;
    }
>>

errorState(s) ::= <<
static class ErrorHandler
{
    public Object reduce(%visitorClass()% visitor, %nodeClass()% node, %nonterminalClass()% goalState)
    {
        %if(s.nonterminal)%
        switch(goalState) {
        case %s.nonterminal%:
            return visitor.%s.patterns.(s.nonterminal).preCallback.name%(node, goalState);
        %s.closures.values:errorClosure();separator="\n"%
        }
        %endif%
        throw new IllegalArgumentException(String.format("No error handler produces \%s", goalState));
    }
}

static final ErrorHandler errorHandler = new ErrorHandler();
>>

nullState(s) ::= <<
// %s%
static class NullHandler
{
    public Object reduce(%visitorClass()% visitor, %nodeClass()% node, %nonterminalClass()% goalState)
    {
        Object result = null;
        switch(goalState) {
            %s.nonterminals:nullReduction();separator="\n"%
            default:
                throw new NullPointerException();
        }
    }
}
static final NullHandler nullHandler = new NullHandler();
>>

nullReduction(nt) ::= <<
case %nt%:
%if(s.patterns.(nt))%
    %s.patterns.(nt): { production | result = visitor.%production.postCallback.name%(node, goalState); }%
%elseif (s.closures.(nt))%
    %s.closurePreProductions.(nt): { production | %production.preCallback% };separator="\n * "%
    %s.patterns.(s.closurePatternPrecursor.(nt)): { production | result = visitor.%production.postCallback.name%(node, goalState); }%
    %s.closurePostProductions.(nt): { production | result = visitor.%production;format="postCallback"% };separator="\n"%
%endif%
    return result;
>>

labelRoutine(op) ::= <<
void %op:operatorSignature()%(%visitorClass()% visitor, %nodeClass()% node)
{
    %if(op.transitionTable)%
    %transitionTable(op.transitionTable)%
    %else%
    %leafReference(op.leafState)%
    %endif%
}
>>

labelRoutines(t) ::= <<
%t.operatorsByNodeType:{ nt | %t.operatorsByNodeType.(nt): { op | %labelRoutine(op);separator="\n\n"% };separator="\n\n"% };separator="\n\n"%
>>

leafDefinition(s) ::= <<
// %s%
static TransitionEntry %s:leafStateName()% = new TransitionEntry()
{
    void assignState(%visitorClass()% visitor, %nodeClass()% node)
    {
        %s.statesByMethod:assignState()%
    }

    Object reduce(%className()% reducer, %visitorClass()% visitor, %nodeClass()% node, %nonterminalClass()% goalState)
    {
        Object result = null;

        switch(goalState) {
            %s.statesByMethod:{ m | %s.statesByMethod.(m):reducer();separator="\n"%}%
            default:
                result = errorHandler.reduce(visitor, node, goalState);
        }

        return result;
    }

    boolean canProduce(%nodeClass()% node, %nonterminalClass()% goalState)
    {
        switch(goalState) {
            %s.statesProducingNonterminal:canProduceNt();separator="\n"%
            default: return false;
        }
    }
};
>>

canProduceNt(nt) ::= <<
case %nt%:
    switch (getStateNumber(node)) {
    %s.statesProducingNonterminal.(nt): { stateNumber |case %stateNumber%: };separator="\n"%
        return true;
    default:
        return false;
    }
>>

leafReference(s) ::= <<
%s:leafStateName()%.assignState(visitor, node);
>>

leafStateName(s) ::=<<%s;format="leafState"%>>

nodeOperators(nodeType, operatorList) ::= <<
case %nodeType%:
    switch(node.getSubtreeCount()) {
        %operatorList:operatorDefinition();separator="\n"%
    }
    break;
>>

operatorDefinition(op) ::= <<
%if(op.variadic)%
default:
    if (node.getSubtreeCount() >= %op.size%) {
        %op:operatorSignature()%(visitor, node);
    }
%else%
case %op.size%:
    %op:operatorSignature()%(visitor, node);
%endif%
    break;
>>

operatorSignature(op) ::= <<%op;format="operatorSignature"%>>

predicatedState(key) ::= <<
if (%key:predicateInvocation();separator=" && "%) {
    node.setStateNumber(%s.statesByMethod.(key).stateNumber%);
    node.setTransitionTableLeaf(this);
}
>>

predicateInvocation(m) ::= <<
visitor.%m.name%(node)
>>

productionTable(t) ::= <<
%t.operatorsByNodeType:{ nt | %nodeOperators(nt, t.operatorsByNodeType.(nt))% }; separator="\n"%
>>

reducer(s) ::= <<
%s.nonterminals:reduceCase();separator="\n"%
>>

reduceCase(nt) ::= <<
case %nt%: {
%if(s.patterns.(nt))%
    %reduction(s.patterns.(nt))%
%elseif (s.closures.(nt))%
    %s.closurePreProductions.(nt): { production | %production.preCallback% };separator="\n * "%
    %reduction(s.patterns.(s.closurePatternPrecursor.(nt)))%
    %s.closurePostProductions.(nt): { production | result = visitor.%production;format="postCallback"% };separator="\n"%
%endif%
    break;
}
>>

reduction(pattern) ::= <<
%if(pattern.preCallback)%
visitor.%pattern.preCallback.name%(node, goalState);
%endif%
%pattern.nonVariadicChildDescriptors: { c | Object result%c.position% = reducer.reduce(visitor, node.getSubtree(%c.position%), %nonterminalClass()%.%c.nonterminal%);};separator="\n"%
%if(pattern.isVarArgs)%
%pattern.postCallback;format="postCallback.variadicType"%[] variadicActuals = new %pattern.postCallback;format="postCallback.variadicType"%[node.getSubtreeCount() - %pattern.postCallback;format="postCallback.variadicOffset"%];
for (int i = 0; i < node.getSubtreeCount() - %pattern.postCallback;format="postCallback.variadicOffset"%; i++) {
    variadicActuals[i] = (%pattern.postCallback;format="postCallback.variadicType"%)reducer.reduce(visitor, node.getSubtree(i + %pattern.postCallback;format="postCallback.variadicOffset"%), %nonterminalClass()%.%pattern.variadicNonterminal%);
}
%endif%
%if(pattern.postCallback)%
result=visitor.%pattern.postCallback;format="postCallback"%;
%else%
// No post callback...
%endif%
>>

transitionTable(t) ::= <<
%if(t.nextDimension.empty)%
switch(getStateNumber(node.getSubtree(%t.dimension%))) {
%t.normalizedFinalDimension:transitionTableLeaf();separator="\n"%
}
%else%
switch(getStateNumber(node.getSubtree(%t.dimension%))) {
%t.nextDimIndexMap:{ s | case %s%:
    %transitionTable(t.nextDimensionByIndex.(s))%};separator="break;\n"%
}
%endif%
>>

transitionTableLeaf(leafReferences) ::= <<
%leafReferences: { ref |
    %ref.stateNumbers: { index | case %index%: };separator="\n"%
        %leafReference(ref.reference)%
        break;
}%
>>
