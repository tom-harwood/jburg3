delimiters "%","%"

// ** Start State **
start(table, includes, uniqueStates) ::= <<
%classDef(table, uniqueStates)%
>>

// ** Property Access **
className() ::= <<%"";format="class.name"%>>

grammar() ::= <<%"";format="grammar.name"%>>

nodeClass() ::= <<%"";format="node.class"%>>

nodeTypeClass() ::= <<%"";format="nodeType.class"%>>

nonterminalClass() ::= <<%"";format="nonterminal.class"%>>

resultType() ::= <<%"";format="result.type"%>>

timestamp() ::=<<%"";format="timestamp"%>>

version() ::= <<%"";format="version"%>>

visitorClass() ::= <<%"";format="visitor.class"%>>

// ** Table Translation, mostly alphabetical **

classDef(table, uniqueStates) ::= <<
/* GENERATED CODE - Edits will be lost
 * Generated by JBurg3 %version()% %timestamp()% %grammar()%
 */

%includes;format="include"%

class %className()%
{
public:
    void label(%visitorClass()%& visitor, %nodeClass()%* node);

    %resultType()% reduce(%visitorClass()%& visitor, %nodeClass()%* node, %nonterminalClass()% goalState);

    bool canProduce(%nodeClass()%* node,  %nonterminalClass()% goalState);

    class TransitionEntry
    {
    public:
        virtual void assignState(%visitorClass()%& visitor, %nodeClass()%* node) = 0;
        virtual %resultType()% reduce(%className()%& reducer, %visitorClass()%& visitor, %nodeClass()%* node, %nonterminalClass()% goalState) = 0;
        virtual bool canProduce(%nodeClass()%* node, %nonterminalClass()% goalState) = 0;
    };

private:
    %labelRoutines(table)%

    %uniqueStates:leafDefinition();separator="\n"%

    %errorState(table.errorState)%
};

namespace jburg {
    static const int ErrorStateNumber = 0;
}
>>

errorState(s) ::= <<
class ErrorHandler
{
public:
    %resultType()% reduce(%visitorClass()%& visitor, %nodeClass()%* node, %nonterminalClass()% goalState);
};

public:
static ErrorHandler errorHandler;
>>

labelRoutine(op) ::= <<
void %op:operatorSignature()%(%visitorClass()%& visitor, %nodeClass()%* node);
>>

labelRoutines(t) ::= <<
%t.operatorsByNodeType:{ nt | %t.operatorsByNodeType.(nt): { op | %labelRoutine(op);separator="\n\n"% };separator="\n\n"% };separator="\n\n"%
>>

leafDefinition(s) ::= <<
// %s%
static TransitionEntry* %s:leafStateName()%;
>>

operatorSignature(op) ::= <<%op;format="operatorSignature"%>>

leafStateName(s) ::=<<%s;format="leafState"%>>
